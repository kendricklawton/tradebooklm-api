// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const addExitLeg = `-- name: AddExitLeg :one
INSERT INTO exit_legs (
    trade_id, exit_date, exit_quantity, exit_price, exit_fees
)
SELECT
    $1, $2, $3, $4, $5
FROM trades t
JOIN tradebooks tb ON t.tradebook_id = tb.id
LEFT JOIN tradebook_members tm ON tb.id = tm.tradebook_id
WHERE t.id = $1
    AND (tb.owner_id = $6 OR (tm.user_id = $6 AND tm.role IN ('owner', 'editor')))
    -- LIMIT CHECK: Ensure we haven't hit 100 legs yet
    AND (SELECT COUNT(*) FROM exit_legs WHERE trade_id = $1) < 100
RETURNING id, trade_id, exit_date, exit_quantity, exit_price, exit_fees, created_at, updated_at
`

type AddExitLegParams struct {
	TradeID      uuid.UUID
	ExitDate     time.Time
	ExitQuantity decimal.Decimal
	ExitPrice    decimal.Decimal
	ExitFees     decimal.NullDecimal
	UserID       string
}

// Security: Verifies ownership AND enforces max 100 exit legs per trade (DB Level Safety Net)
func (q *Queries) AddExitLeg(ctx context.Context, arg AddExitLegParams) (ExitLeg, error) {
	row := q.db.QueryRowContext(ctx, addExitLeg,
		arg.TradeID,
		arg.ExitDate,
		arg.ExitQuantity,
		arg.ExitPrice,
		arg.ExitFees,
		arg.UserID,
	)
	var i ExitLeg
	err := row.Scan(
		&i.ID,
		&i.TradeID,
		&i.ExitDate,
		&i.ExitQuantity,
		&i.ExitPrice,
		&i.ExitFees,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTrade = `-- name: CreateTrade :one

INSERT INTO trades (
    tradebook_id, asset_class, purchase_type, order_type,
    entry_date, symbol, currency, entry_quantity, entry_price, entry_fees
)
SELECT
    $1, $2, $3, $4,
    $5, $6, $7, $8, $9, $10
WHERE EXISTS (
    SELECT 1 FROM tradebooks tb
    LEFT JOIN tradebook_members tm ON tb.id = tm.tradebook_id
    WHERE tb.id = $1
    AND (
        tb.owner_id = $11
        OR (tm.user_id = $11 AND tm.role IN ('owner', 'editor'))
    )
)
RETURNING id, tradebook_id, is_open, asset_class, purchase_type, order_type, entry_date, symbol, currency, entry_quantity, entry_price, entry_fees, created_at, updated_at
`

type CreateTradeParams struct {
	TradebookID   uuid.UUID
	AssetClass    AssetClass
	PurchaseType  TradePurchaseType
	OrderType     TradeOrderType
	EntryDate     time.Time
	Symbol        string
	Currency      string
	EntryQuantity decimal.Decimal
	EntryPrice    decimal.Decimal
	EntryFees     decimal.NullDecimal
	UserID        string
}

// ============================================================================
// 4. TRADES
// ============================================================================
func (q *Queries) CreateTrade(ctx context.Context, arg CreateTradeParams) (Trade, error) {
	row := q.db.QueryRowContext(ctx, createTrade,
		arg.TradebookID,
		arg.AssetClass,
		arg.PurchaseType,
		arg.OrderType,
		arg.EntryDate,
		arg.Symbol,
		arg.Currency,
		arg.EntryQuantity,
		arg.EntryPrice,
		arg.EntryFees,
		arg.UserID,
	)
	var i Trade
	err := row.Scan(
		&i.ID,
		&i.TradebookID,
		&i.IsOpen,
		&i.AssetClass,
		&i.PurchaseType,
		&i.OrderType,
		&i.EntryDate,
		&i.Symbol,
		&i.Currency,
		&i.EntryQuantity,
		&i.EntryPrice,
		&i.EntryFees,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTradebook = `-- name: CreateTradebook :one

INSERT INTO tradebooks (owner_id, title)
VALUES ($1, $2)
RETURNING id, owner_id, title, created_at, updated_at
`

type CreateTradebookParams struct {
	OwnerID string
	Title   string
}

// ============================================================================
// 2. TRADEBOOKS
// ============================================================================
func (q *Queries) CreateTradebook(ctx context.Context, arg CreateTradebookParams) (Tradebook, error) {
	row := q.db.QueryRowContext(ctx, createTradebook, arg.OwnerID, arg.Title)
	var i Tradebook
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAllTradebooks = `-- name: DeleteAllTradebooks :exec
DELETE FROM tradebooks
WHERE owner_id = $1
`

func (q *Queries) DeleteAllTradebooks(ctx context.Context, userID string) error {
	_, err := q.db.ExecContext(ctx, deleteAllTradebooks, userID)
	return err
}

const deleteTrade = `-- name: DeleteTrade :exec
DELETE FROM trades
USING tradebooks tb, tradebook_members tm
WHERE trades.id = $1
    AND trades.tradebook_id = tb.id
    AND tb.id = tm.tradebook_id
    AND (tb.owner_id = $2 OR (tm.user_id = $2 AND tm.role IN ('owner', 'editor')))
`

type DeleteTradeParams struct {
	TradeID uuid.UUID
	UserID  string
}

func (q *Queries) DeleteTrade(ctx context.Context, arg DeleteTradeParams) error {
	_, err := q.db.ExecContext(ctx, deleteTrade, arg.TradeID, arg.UserID)
	return err
}

const deleteTradebook = `-- name: DeleteTradebook :exec
DELETE FROM tradebooks
WHERE id = $1 AND owner_id = $2
`

type DeleteTradebookParams struct {
	TradebookID uuid.UUID
	UserID      string
}

func (q *Queries) DeleteTradebook(ctx context.Context, arg DeleteTradebookParams) error {
	_, err := q.db.ExecContext(ctx, deleteTradebook, arg.TradebookID, arg.UserID)
	return err
}

const getExitLegCount = `-- name: GetExitLegCount :one

SELECT COUNT(*) FROM exit_legs WHERE trade_id = $1
`

// ============================================================================
// 5. EXIT LEGS
// ============================================================================
// Used for Code-Level check before insertion
func (q *Queries) GetExitLegCount(ctx context.Context, tradeID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, getExitLegCount, tradeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getOpenPositions = `-- name: GetOpenPositions :many

SELECT t.id, t.tradebook_id, t.is_open, t.asset_class, t.purchase_type, t.order_type, t.entry_date, t.symbol, t.currency, t.entry_quantity, t.entry_price, t.entry_fees, t.created_at, t.updated_at
FROM trades t
JOIN tradebooks tb ON t.tradebook_id = tb.id
LEFT JOIN tradebook_members tm ON tb.id = tm.tradebook_id
WHERE t.tradebook_id = $1
    AND t.is_open = TRUE
    AND (tb.owner_id = $2 OR tm.user_id = $2)
ORDER BY t.entry_date DESC
`

type GetOpenPositionsParams struct {
	TradebookID uuid.UUID
	UserID      string
}

// ============================================================================
// 6. DASHBOARD
// ============================================================================
func (q *Queries) GetOpenPositions(ctx context.Context, arg GetOpenPositionsParams) ([]Trade, error) {
	rows, err := q.db.QueryContext(ctx, getOpenPositions, arg.TradebookID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Trade
	for rows.Next() {
		var i Trade
		if err := rows.Scan(
			&i.ID,
			&i.TradebookID,
			&i.IsOpen,
			&i.AssetClass,
			&i.PurchaseType,
			&i.OrderType,
			&i.EntryDate,
			&i.Symbol,
			&i.Currency,
			&i.EntryQuantity,
			&i.EntryPrice,
			&i.EntryFees,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrade = `-- name: GetTrade :one
SELECT t.id, t.tradebook_id, t.is_open, t.asset_class, t.purchase_type, t.order_type, t.entry_date, t.symbol, t.currency, t.entry_quantity, t.entry_price, t.entry_fees, t.created_at, t.updated_at FROM trades t
JOIN tradebooks tb ON t.tradebook_id = tb.id
LEFT JOIN tradebook_members tm ON tb.id = tm.tradebook_id
WHERE t.id = $1
    AND (tb.owner_id = $2 OR tm.user_id = $2)
`

type GetTradeParams struct {
	TradeID uuid.UUID
	UserID  string
}

func (q *Queries) GetTrade(ctx context.Context, arg GetTradeParams) (Trade, error) {
	row := q.db.QueryRowContext(ctx, getTrade, arg.TradeID, arg.UserID)
	var i Trade
	err := row.Scan(
		&i.ID,
		&i.TradebookID,
		&i.IsOpen,
		&i.AssetClass,
		&i.PurchaseType,
		&i.OrderType,
		&i.EntryDate,
		&i.Symbol,
		&i.Currency,
		&i.EntryQuantity,
		&i.EntryPrice,
		&i.EntryFees,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTradebook = `-- name: GetTradebook :one
SELECT
    tb.id, tb.owner_id, tb.title, tb.created_at, tb.updated_at,
    COALESCE(tm.role, 'owner')::tradebook_role AS user_role
FROM tradebooks tb
LEFT JOIN tradebook_members tm
    ON tb.id = tm.tradebook_id AND tm.user_id = $1
WHERE tb.id = $2
    AND (tb.owner_id = $1 OR tm.user_id IS NOT NULL)
`

type GetTradebookParams struct {
	UserID      string
	TradebookID uuid.UUID
}

type GetTradebookRow struct {
	ID        uuid.UUID
	OwnerID   string
	Title     string
	CreatedAt time.Time
	UpdatedAt time.Time
	UserRole  TradebookRole
}

func (q *Queries) GetTradebook(ctx context.Context, arg GetTradebookParams) (GetTradebookRow, error) {
	row := q.db.QueryRowContext(ctx, getTradebook, arg.UserID, arg.TradebookID)
	var i GetTradebookRow
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserRole,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, created_at, updated_at FROM users
WHERE id = $1
`

func (q *Queries) GetUser(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const listExitLegs = `-- name: ListExitLegs :many
SELECT el.id, el.trade_id, el.exit_date, el.exit_quantity, el.exit_price, el.exit_fees, el.created_at, el.updated_at FROM exit_legs el
JOIN trades t ON el.trade_id = t.id
JOIN tradebooks tb ON t.tradebook_id = tb.id
LEFT JOIN tradebook_members tm ON tb.id = tm.tradebook_id
WHERE t.id = $1
    AND (tb.owner_id = $2 OR tm.user_id = $2)
ORDER BY el.exit_date ASC
`

type ListExitLegsParams struct {
	TradeID uuid.UUID
	UserID  string
}

func (q *Queries) ListExitLegs(ctx context.Context, arg ListExitLegsParams) ([]ExitLeg, error) {
	rows, err := q.db.QueryContext(ctx, listExitLegs, arg.TradeID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExitLeg
	for rows.Next() {
		var i ExitLeg
		if err := rows.Scan(
			&i.ID,
			&i.TradeID,
			&i.ExitDate,
			&i.ExitQuantity,
			&i.ExitPrice,
			&i.ExitFees,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTradebooks = `-- name: ListTradebooks :many
SELECT
    tb.id, tb.owner_id, tb.title, tb.created_at, tb.updated_at,
    COALESCE(tm.role, 'owner')::tradebook_role AS user_role
FROM tradebooks tb
LEFT JOIN tradebook_members tm
    ON tb.id = tm.tradebook_id AND tm.user_id = $1
WHERE tb.owner_id = $1
    OR tm.user_id = $1
ORDER BY tb.updated_at DESC
LIMIT $3 OFFSET $2
`

type ListTradebooksParams struct {
	UserID    string
	OffsetVal int32
	LimitVal  int32
}

type ListTradebooksRow struct {
	ID        uuid.UUID
	OwnerID   string
	Title     string
	CreatedAt time.Time
	UpdatedAt time.Time
	UserRole  TradebookRole
}

func (q *Queries) ListTradebooks(ctx context.Context, arg ListTradebooksParams) ([]ListTradebooksRow, error) {
	rows, err := q.db.QueryContext(ctx, listTradebooks, arg.UserID, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTradebooksRow
	for rows.Next() {
		var i ListTradebooksRow
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTrades = `-- name: ListTrades :many
SELECT t.id, t.tradebook_id, t.is_open, t.asset_class, t.purchase_type, t.order_type, t.entry_date, t.symbol, t.currency, t.entry_quantity, t.entry_price, t.entry_fees, t.created_at, t.updated_at FROM trades t
JOIN tradebooks tb ON t.tradebook_id = tb.id
LEFT JOIN tradebook_members tm ON tb.id = tm.tradebook_id
WHERE t.tradebook_id = $1
    AND (tb.owner_id = $2 OR tm.user_id = $2)
ORDER BY t.entry_date DESC
LIMIT $4 OFFSET $3
`

type ListTradesParams struct {
	TradebookID uuid.UUID
	UserID      string
	OffsetVal   int32
	LimitVal    int32
}

func (q *Queries) ListTrades(ctx context.Context, arg ListTradesParams) ([]Trade, error) {
	rows, err := q.db.QueryContext(ctx, listTrades,
		arg.TradebookID,
		arg.UserID,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Trade
	for rows.Next() {
		var i Trade
		if err := rows.Scan(
			&i.ID,
			&i.TradebookID,
			&i.IsOpen,
			&i.AssetClass,
			&i.PurchaseType,
			&i.OrderType,
			&i.EntryDate,
			&i.Symbol,
			&i.Currency,
			&i.EntryQuantity,
			&i.EntryPrice,
			&i.EntryFees,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logTokenUsage = `-- name: LogTokenUsage :exec

INSERT INTO token_usage_log (
    user_id, model_name, prompt_tokens, completion_tokens, total_tokens, cost
) VALUES (
    $1, $2, $3, $4, $5, $6
)
`

type LogTokenUsageParams struct {
	UserID           string
	ModelName        string
	PromptTokens     int32
	CompletionTokens int32
	TotalTokens      int32
	Cost             decimal.Decimal
}

// ============================================================================
// 7. METERING
// ============================================================================
func (q *Queries) LogTokenUsage(ctx context.Context, arg LogTokenUsageParams) error {
	_, err := q.db.ExecContext(ctx, logTokenUsage,
		arg.UserID,
		arg.ModelName,
		arg.PromptTokens,
		arg.CompletionTokens,
		arg.TotalTokens,
		arg.Cost,
	)
	return err
}

const removeTradebookMember = `-- name: RemoveTradebookMember :exec
DELETE FROM tradebook_members
WHERE tradebook_id = $1
    AND user_id = $2
    AND EXISTS (
        SELECT 1 FROM tradebooks
        WHERE id = $1 AND owner_id = $3
    )
`

type RemoveTradebookMemberParams struct {
	TradebookID  uuid.UUID
	TargetUserID string
	OwnerID      string
}

func (q *Queries) RemoveTradebookMember(ctx context.Context, arg RemoveTradebookMemberParams) error {
	_, err := q.db.ExecContext(ctx, removeTradebookMember, arg.TradebookID, arg.TargetUserID, arg.OwnerID)
	return err
}

const updateTrade = `-- name: UpdateTrade :one
UPDATE trades
SET
    is_open = COALESCE($1, is_open),
    updated_at = NOW()
FROM tradebooks tb
LEFT JOIN tradebook_members tm ON tb.id = tm.tradebook_id
WHERE trades.id = $2
    AND trades.tradebook_id = tb.id
    AND (tb.owner_id = $3 OR (tm.user_id = $3 AND tm.role IN ('owner', 'editor')))
RETURNING trades.id, trades.tradebook_id, trades.is_open, trades.asset_class, trades.purchase_type, trades.order_type, trades.entry_date, trades.symbol, trades.currency, trades.entry_quantity, trades.entry_price, trades.entry_fees, trades.created_at, trades.updated_at
`

type UpdateTradeParams struct {
	IsOpen  sql.NullBool
	TradeID uuid.UUID
	UserID  string
}

func (q *Queries) UpdateTrade(ctx context.Context, arg UpdateTradeParams) (Trade, error) {
	row := q.db.QueryRowContext(ctx, updateTrade, arg.IsOpen, arg.TradeID, arg.UserID)
	var i Trade
	err := row.Scan(
		&i.ID,
		&i.TradebookID,
		&i.IsOpen,
		&i.AssetClass,
		&i.PurchaseType,
		&i.OrderType,
		&i.EntryDate,
		&i.Symbol,
		&i.Currency,
		&i.EntryQuantity,
		&i.EntryPrice,
		&i.EntryFees,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTradebook = `-- name: UpdateTradebook :one
UPDATE tradebooks
SET
    title = COALESCE($1, title),
    updated_at = NOW()
WHERE id = $2
    AND owner_id = $3
RETURNING id, owner_id, title, created_at, updated_at
`

type UpdateTradebookParams struct {
	Title       sql.NullString
	TradebookID uuid.UUID
	UserID      string
}

func (q *Queries) UpdateTradebook(ctx context.Context, arg UpdateTradebookParams) (Tradebook, error) {
	row := q.db.QueryRowContext(ctx, updateTradebook, arg.Title, arg.TradebookID, arg.UserID)
	var i Tradebook
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertTradebookMember = `-- name: UpsertTradebookMember :one

WITH authorized_check AS (
    -- Only proceed if the @owner_id is the actual owner of the tradebook
    SELECT 1
    FROM tradebooks
    WHERE id = $1 AND owner_id = $4
)
INSERT INTO tradebook_members (tradebook_id, user_id, role)
SELECT $1, $2, $3
FROM authorized_check
ON CONFLICT (tradebook_id, user_id) DO UPDATE
SET
    role = EXCLUDED.role
RETURNING tradebook_id, user_id, role, joined_at
`

type UpsertTradebookMemberParams struct {
	TradebookID uuid.UUID
	NewMemberID string
	Role        TradebookRole
	OwnerID     string
}

// ============================================================================
// 3. MEMBERS (Refactored to use UPSERT)
// ============================================================================
func (q *Queries) UpsertTradebookMember(ctx context.Context, arg UpsertTradebookMemberParams) (TradebookMember, error) {
	row := q.db.QueryRowContext(ctx, upsertTradebookMember,
		arg.TradebookID,
		arg.NewMemberID,
		arg.Role,
		arg.OwnerID,
	)
	var i TradebookMember
	err := row.Scan(
		&i.TradebookID,
		&i.UserID,
		&i.Role,
		&i.JoinedAt,
	)
	return i, err
}

const upsertUser = `-- name: UpsertUser :one

INSERT INTO users (id)
VALUES ($1)
ON CONFLICT (id) DO UPDATE
SET updated_at = NOW()
RETURNING id, created_at, updated_at
`

// ============================================================================
// 1. USERS
// ============================================================================
func (q *Queries) UpsertUser(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, upsertUser, id)
	var i User
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}
